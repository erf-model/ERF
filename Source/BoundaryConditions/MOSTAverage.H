#ifndef MOSTAverage_H
#define MOSTAverage_H

#include <AMReX_Gpu.H>
#include <AMReX_FArrayBox.H>
#include <AMReX_MultiFab.H>
#include <AMReX_iMultiFab.H>
#include <AMReX_ParmParse.H>
#include <IndexDefines.H>
#include <TerrainMetrics.H>

class MOSTAverage {
public:
    explicit MOSTAverage(const amrex::Vector<amrex::Geometry>& geom,
                         amrex::Vector<amrex::Vector<amrex::MultiFab>>& vars_old,
                         amrex::Vector<std::unique_ptr<amrex::MultiFab>>& Theta_prim,
                         amrex::Vector<std::unique_ptr<amrex::MultiFab>>& z_phys_nd);
    MOSTAverage() = default;
    ~MOSTAverage()
    {
        for (int lev(0); lev<m_maxlev; ++lev){
            for (int iavg(0); iavg<m_navg; ++iavg) delete m_averages[lev][iavg];
            delete m_k_indx[lev];
            delete m_j_indx[lev];
            delete m_i_indx[lev];
        }
    };

    // Reset the pointers to field MFs
    void update_field_ptrs(int lev,
                           amrex::Vector<amrex::Vector<amrex::MultiFab>>& vars_old,
                           amrex::Vector<std::unique_ptr<amrex::MultiFab>>& Theta_prim);

    // Compute ncells per plane
    void set_plane_normalization();

    // Compute ncells per plane
    void set_region_normalization()
    {m_ncell_region = (2 * m_radius + 1) * (2 * m_radius + 1) * (2 * m_radius + 1);};

    // Populate a 2D iMF w/o terrain (k_indx)
    void set_k_indices_N();

    // Populate a 2D iMF with terrain (k_indx)
    void set_k_indices_T();

    // Populate all 2D iMFs with terrain (ijk_indx)
    void set_ijk_indices_T();

    // Driver for the different average policies
    void compute_averages(int lev);

    // Fill averages for policy::plane
    void compute_plane_averages(int lev);

    // Fill averages for policy::point
    void compute_region_averages(int lev);

    // Write k indices
    void write_k_indices(int lev);

    // Write ijk indices
    void write_ijk_indices(int lev);

    // Write XZ planar positions
    void write_XZ_planar_positions(int lev, int lj);

    // Write averages on 2D mf
    void write_averages(int lev);

    // Get pointer to the 2D mf of averages
    const amrex::MultiFab* get_average(int lev, int comp) const { return m_averages[lev][comp]; };

    // Get z_ref (may be computed from specified k_indx)
    amrex::Real get_zref() { return m_zref; };

protected:

    // Passed through constructor
    //--------------------------------------------
    const amrex::Vector<amrex::Geometry> m_geom;                     // Geometry at each level
    amrex::Vector<amrex::Vector<amrex::MultiFab*>> m_fields;         // Ptr to fields to be averaged
    amrex::Vector<amrex::MultiFab*> m_z_phys_nd;                     // Ptr to terrain heigh coords

    // General vars for multiple or all policies
    //--------------------------------------------
    int m_nvar{3};                                                   // 3 fields for U/V/T
    int m_navg{4};                                                   // 4 averages for U/V/T/Umag
    int m_maxlev{0};                                                 // Total number of levels
    int m_policy{0};                                                 // Policy for type of averaging
    amrex::Real m_zref{-1.0};                                        // Height above surface for MOST BC
    std::string m_pp_prefix {"erf"};                                 // ParmParse prefix
    amrex::Vector<amrex::iMultiFab*> m_k_indx;                       // Ptr to 2D imf to hold k indices (maxlev)
    amrex::Vector<amrex::iMultiFab*> m_j_indx;                       // Ptr to 2D imf to hold j indices (maxlev)
    amrex::Vector<amrex::iMultiFab*> m_i_indx;                       // Ptr to 2D imf to hold i indices (maxlev)
    amrex::Vector<amrex::Vector<amrex::MultiFab*>> m_averages;       // Ptr to 2D mf to hold averages (maxlev,navg)

    // Vars for planar average policy
    //--------------------------------------------
    amrex::Vector<amrex::Vector<int>> m_ncell_plane;                 // Number of cells in plane (maxlev,navg)
    amrex::Vector<amrex::Vector<amrex::Real>> m_plane_average;       // Plane avgs (maxlev,navg)

    // Vars for point/region average policy
    //--------------------------------------------
    int m_radius{0};                                                 // Radius around k_index
    int m_ncell_region{1};                                           // Number of cells in local region
    amrex::Vector<int> m_k_in;                                       // Specified k_index for region avg (maxlev)

    // Vars for normal vector policy
    //--------------------------------------------
    bool m_norm_vec{false};                                          // Use normal vector to find IJK?

    // Time average w/ exponential filter fun
    //--------------------------------------------
    bool m_t_avg{false};                                             // Flag to do moving average in time
    amrex::Vector<int> m_t_init;                                     // Flag to specify if averages are initialized
    amrex::Real m_time_window{1.0e-16};                              // Width of the exp filter function
    amrex::Real m_fact_new, m_fact_old;                              // Time average factors for new and old means
};
#endif
