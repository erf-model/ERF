#include <iomanip>
#include <iostream>
#include <string>
#include <ctime>

#ifdef _OPENMP
#include <omp.h>
#endif

#include <AMReX_Utility.H>
#include <AMReX_buildInfo.H>
#include <AMReX_ParmParse.H>

#include "ERF.H"
#include "IOManager.H"
#include "NCInterface.H"
#include "NCPlotFile.H"
#include "IndexDefines.H"

// ERF maintains an internal checkpoint version numbering system.
// This allows us to maintain backwards compatibility with checkpoints
// generated by old versions of the code, so that new versions can
// restart from them. The version number is stored in the ERFHeader
// file inside a checkpoint. The following were the changes that were made
// in updating version numbers:
// 0: all checkpoints as of 11/21/16
// 1: add body state

namespace {
 int input_version = -1;
 int current_version = 1;
 const std::string CheckPointVersion("CheckPointVersion_1.0");
 std::string nc_state_filename = "Plot_State_MF.nc";
 amrex::Real vfraceps = 0.000001;
} // namespace

// I/O routines for ERF
void
IOManager::ncrestart(amrex::Amr& papa, istream& is, bool bReadSpecial)
{
    // Let's check ERF checkpoint version first;
    // trying to read from checkpoint; if nonexisting, set it to 0.
    if (input_version == -1) {
      if (amrex::ParallelDescriptor::IOProcessor()) {
        std::ifstream ERFHeaderFile;
        std::string FullPathERFHeaderFile = papa.theRestartFile();
        FullPathERFHeaderFile += "/ERFHeader";
        ERFHeaderFile.open(FullPathERFHeaderFile.c_str(), std::ios::in);
        if (ERFHeaderFile.good()) {
          char foo[256];
          ERFHeaderFile.getline(foo, 256, ':');
          ERFHeaderFile >> input_version;
          ERFHeaderFile.close();
        } else {
          input_version = 0;
        }
      }
      amrex::ParallelDescriptor::Bcast(
        &input_version, 1, amrex::ParallelDescriptor::IOProcessorNumber());
    }

    AMREX_ASSERT(input_version >= 0);

    erf.parent = &papa;

    // This is urgly in NetCDF input/output, we should store everything in NetCDF file, however,
    // the directory layout is the way need to know the level before it can read the file.
    // TODO: we need find a way to reorganize the output directory structure later.
    is >> erf.level;

    std::string LevelDir, FullPath;
    LevelDir = amrex::Concatenate("Level_", erf.level, 1);
    erf.LevelDirectoryNames(papa.theRestartFile(), LevelDir, FullPath);
    if( ! erf.levelDirectoryCreated) {
      amrex::Print() << "ERF::ncrestart: NetCDF restart file doesn't exist!" << '\n';
    }

    auto ncf = ncutils::NCFile::open(FullPath+"/SD_New_MF.nc");

    std::vector<int> data;
    ncf.get_attr("Level", data);
    erf.level = data[0];

    ncf.get_attr("finest_level",data);
    papa.SetFinestLevel(data[0]);
    int nflev = data[0];

    ncf.get_attr("CoordSys_ID", data);
    int coord = data[0];
    erf.geom.SetCoord(static_cast<amrex::CoordSys::CoordType>(data[0]));

    std::vector<amrex::Real> offset(AMREX_SPACEDIM);
    std::vector<amrex::Real> cellsize(AMREX_SPACEDIM);
    ncf.var("Coord.Offset").get(offset.data(), {0}, {AMREX_SPACEDIM});
    ncf.var("Coord.CellSize").get(cellsize.data(), {0}, {AMREX_SPACEDIM});

    erf.geom.SetOffset(offset.data());
    // TODO (this is important)
    // we need to setup the cellsize to coordinate here!!!
//    geom.SetCellsize(cellsize.data());

    amrex::IntVect lo(AMREX_SPACEDIM);
    amrex::IntVect hi(AMREX_SPACEDIM);
    amrex::IntVect type(AMREX_SPACEDIM);
    ncf.var("Domain.SmallEnd").get(lo.begin(), {0}, {AMREX_SPACEDIM});
    ncf.var("Domain.BigEnd").get(hi.begin(), {0}, {AMREX_SPACEDIM});
    ncf.var("Domain.BType").get(type.begin(), {0}, {AMREX_SPACEDIM});

    amrex::Box bx = amrex::Box(lo,hi,type);

    amrex::Real plo[AMREX_SPACEDIM];
    amrex::Real phi[AMREX_SPACEDIM];
    ncf.var("PDomain.Lo").get(plo, {0}, {AMREX_SPACEDIM});
    ncf.var("PDomain.Hi").get(phi, {0}, {AMREX_SPACEDIM});

    amrex::RealBox rb = amrex::RealBox(plo, phi);

    erf.geom.Domain(bx);
    erf.geom.ProbDomain(rb);

    amrex::IntArray periodic;
    ncf.var("Geom.Periodic").get(periodic.begin(), {0}, {AMREX_SPACEDIM});

    erf.geom.setPeriodicity({{AMREX_D_DECL(periodic[0],periodic[1],periodic[2])}});

    // setup geom
    erf.geom.define(bx, rb, coord, periodic);

    erf.fine_ratio = amrex::IntVect::TheUnitVector(); erf.fine_ratio.scale(-1);
    erf.crse_ratio = amrex::IntVect::TheUnitVector(); erf.crse_ratio.scale(-1);

    if (erf.level > 0) {
       erf.crse_ratio = papa.refRatio(erf.level-1);
    }

    if (erf.level < papa.maxLevel()) {
       erf.fine_ratio = papa.refRatio(erf.level);
    }

    auto grids_dim = ncf.dim("num_grids");
    int num_grids = static_cast<int>(grids_dim.len());
    erf.grids.resize(num_grids);

    for (auto ib=0; ib<num_grids; ++ib) {
       int blo[AMREX_SPACEDIM];
       int bhi[AMREX_SPACEDIM];
       int btype[AMREX_SPACEDIM];

       ncf.var("Grids.SmallEnd").get(blo, {ib, 0}, {1, AMREX_SPACEDIM});
       ncf.var("Grids.BigEnd").get(bhi, {ib, 0}, {1, AMREX_SPACEDIM});
       ncf.var("Grids.BType").get(btype, {ib, 0}, {1, AMREX_SPACEDIM});

       amrex::Box b = amrex::Box(amrex::IntVect(blo), amrex::IntVect(bhi), amrex::IntVect(btype));
       erf.grids.set(ib, b);
    }

    int ndesc = erf.desc_lst.size();
    int nstate = ndesc;

    amrex::Vector<int> state_in_checkpoint(ndesc, 1);
    if (ndesc > nstate) {
        erf.set_state_in_checkpoint(state_in_checkpoint);
    } else {
        BL_ASSERT(nstate == ndesc);
    }

    erf.dmap.define(erf.grids);
    papa.SetBoxArray(erf.level, erf.grids);
    papa.SetDistributionMap(erf.level, erf.dmap);
    erf.m_factory.reset(new amrex::FArrayBoxFactory());

    erf.state.resize(ndesc);

    amrex::Vector<int> npts;
    amrex::Vector<int> nsize;
    amrex::Vector<int> nblocks;
    amrex::Vector<std::string> lo_names;
    amrex::Vector<std::string> hi_names;
    amrex::Vector<std::string> typ_names;
    amrex::Vector<std::string> var_names;
    std::map<std::pair<int, int>, int> var_map;
    int inc = 0;
    for (int typ = 0; typ < erf.desc_lst.size(); typ++) {
        for (int comp = 0; comp < erf.desc_lst[typ].nComp(); comp++) {
           std::string name;
           std::pair<int, int> p {std::pair<int, int>(typ, comp)};
           var_map[p] = inc;
           if (erf.desc_lst[typ].name(comp) != "") {
              name = erf.desc_lst[typ].name(comp);
           } else {
              name = EnumToString(static_cast<StateType>(typ));
           }
             var_names.push_back(name.c_str());
             ++inc;
       }
    }

    for (int k = 0; k < var_names.size(); ++k) {
       int num_pts = static_cast<int>(ncf.dim("num_points_"+std::to_string(k)).len());
       int num_size = static_cast<int>(ncf.dim("nsize_"+std::to_string(k)).len());
       npts.push_back(num_pts);
       nsize.push_back(num_size);
    }

    for (int k = 0; k < erf.desc_lst.size(); ++k) {
      std::string typ_name = EnumToString(static_cast<StateType>(k));
      lo_names.push_back("lo_"+typ_name);
      hi_names.push_back("hi_"+typ_name);
      typ_names.push_back("typ_"+typ_name);
      int num_box = static_cast<int>(ncf.dim("num_boxs_"+std::to_string(k)).len());
      nblocks.push_back(num_box);
    }

    for (int i = 0; i < ndesc; ++i) {
        if (state_in_checkpoint[i]) {

           amrex::Real time, dt_new, dt_old;
           ncf.get_attr("cumtime",data);
           time = static_cast<amrex::Real>(data[0]);
           ncf.get_attr("DtNew",data);
           dt_new = static_cast<amrex::Real>(data[0]);
           ncf.get_attr("DtOld",data);
           dt_old = static_cast<amrex::Real>(data[0]);

           auto state_domain = erf.geom.Domain();
           auto state_grids  = erf.grids;

           amrex::IndexType typ(erf.desc_lst[i].getType());
           if (!typ.cellCentered()) {
             state_domain.convert(typ);
             state_grids.convert(typ);
           }

           amrex::Arena* arena = nullptr;

           // initialize state
           erf.state[i].define(state_domain, state_grids, erf.dmap, erf.desc_lst[i], time, dt_new, *(erf.m_factory));

           amrex::MultiFab& new_data = erf.state[i].newData();

           // initialize multifab
           new_data.define(state_grids,erf.dmap,erf.desc_lst[i].nComp(),erf.desc_lst[i].nExtra(),
                            amrex::MFInfo().SetTag("StateData").SetArena(arena),
                            *(erf.m_factory));

           new_data.setVal(0.);

           erf.state[i].setTimeLevel(time, dt_old, dt_new);

          for (amrex::MFIter new_mfi(new_data); new_mfi.isValid(); ++new_mfi) {
              auto ncomp   = new_data.nComp();

              amrex::IntVect smallend(AMREX_SPACEDIM);
              amrex::IntVect bigend(AMREX_SPACEDIM);
              amrex::IntVect itype(AMREX_SPACEDIM);

              ncf.var(lo_names[i] ).get(smallend.begin(), {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});
              ncf.var(hi_names[i] ).get(bigend.begin()  , {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});
              ncf.var(typ_names[i]).get(itype.begin()   , {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});

              amrex::Box fab_box = amrex::Box(smallend, bigend, itype);

              amrex::FArrayBox &fab = new_data[new_mfi.index()];

              for(int k(0); k < fab.nComp(); ++k) {
                 auto dataPtr = fab.dataPtr(k);
                 std::pair<int, int> p {std::pair<int, int>(i, k)};
                 int index = var_map[p];
                 ncf.var(var_names[index]).get(dataPtr, {new_mfi.index(), 0}, {1, npts[index]});
              }
          }
       }
    }

    if (papa.useFixedCoarseGrids()) {
      erf.constructAreaNotToTag();
    }

    erf.post_step_regrid = 0;

    erf.finishConstructor();

  /*
    Deal here with new state descriptor types added, with corresponding
    input_version > 0, if applicable
   */
  for (int i = 0; i < erf.desc_lst.size(); ++i) {
    if (state_in_checkpoint[i] == 0) {
      const amrex::Real ctime = erf.state[i-1].curTime();
      erf.state[i].define(
        erf.geom.Domain(), erf.grids, erf.dmap, erf.desc_lst[i], ctime, papa.dtLevel(erf.level),
        *(erf.m_factory));
      erf.state[i] = erf.state[i - 1];
    }
  }
  erf.buildMetrics();

  // get the elapsed CPU time to now;
  if (erf.level == 0 && amrex::ParallelDescriptor::IOProcessor()) {
    // get elapsed CPU time
    std::ifstream CPUFile;
    std::string FullPathCPUFile = papa.theRestartFile();
    FullPathCPUFile += "/CPUtime";
    CPUFile.open(FullPathCPUFile.c_str(), std::ios::in);
    CPUFile >> erf.previousCPUTimeUsed;
    CPUFile.close();
    amrex::Print() << "read CPU time: " << erf.previousCPUTimeUsed << "\n";
  }

  /* Deprecated: erf.track_grid_losses is not a supported option
  if (erf.track_grid_losses && erf.level == 0) {

    // get the current value of the diagnostic quantities
    std::ifstream DiagFile;
    std::string FullPathDiagFile = papa.theRestartFile();
    FullPathDiagFile += "/Diagnostics";
    DiagFile.open(FullPathDiagFile.c_str(), std::ios::in);

    DiagFile.close();
  }
  */

  /*Not implemented for CUDA
      if (level == 0)
      {
    // get problem-specific stuff -- note all processors do this,
    // eliminating the need for a broadcast
    std::string dir = parent->theRestartFile();

    char * dir_for_pass = new char[dir.size() + 1];
    std::copy(dir.begin(), dir.end(), dir_for_pass);
    dir_for_pass[dir.size()] = '\0';

    int len = dir.size();

    Vector<int> int_dir_name(len);
    for (int j = 0; j < len; j++)
        int_dir_name[j] = (int) dir_for_pass[j];

    AMREX_FORT_PROC_CALL(PROBLEM_RESTART,problem_restart)(int_dir_name.dataPtr(),
    &len);

    delete [] dir_for_pass;

      }*/
}

void
IOManager::writeNCPlotFile(const std::string& dir, ostream& os)
{
  int i, j, n;
  // number of blocks in this level
  int nblocks;
  // number of grid points at this block
  int num_pts;
  // number of cells in each block
  std::vector<int> n_cells;
  // finest level
  int flev;

  // set the full IO path for NetCDF output
  static const std::string BaseName = "/NetCDF";
  char buf[64];
  sprintf(buf, "Level_%d", erf.level);
  std::string LevelStr = buf;

  std::cout << "Write NetCDF file!" << '\n';

  std::string FullPath = dir;
  if (!FullPath.empty() && FullPath[FullPath.size() - 1] != '/') FullPath += '/';
  FullPath += LevelStr;
  FullPath += BaseName;

  if (amrex::ParallelDescriptor::IOProcessor())
    if (!amrex::UtilCreateDirectory(FullPath, 0755))
      amrex::CreateDirectoryFailed(FullPath);

  if (!amrex::ParallelDescriptor::IOProcessor()) return;

  // open netcdf file to write data
  auto ncf = ncutils::NCFile::create(FullPath+'/'+nc_state_filename, NC_CLOBBER | NC_NETCDF4);

  nblocks = erf.numGrids();
  flev = erf.parent->finestLevel();

#if (AMREX_SPACEDIM == 1)
  n_cells.push_back(amrex::length(erf.boxArray()[0]).x);
  num_pts = amrex::length(erf.boxArray()[0]).x;
#elif (AMREX_SPACEDIM == 2)
  n_cells.push_back(amrex::length(erf.boxArray()[0]).x);
  n_cells.push_back(amrex::length(erf.boxArray()[0]).y);
  num_pts = (amrex::length(erf.boxArray()[0]).x)*(amrex::length(erf.boxArray()[0]).y);
#elif (AMREX_SPACEDIM == 3)
  n_cells.push_back(amrex::length(erf.boxArray()[0]).x);
  n_cells.push_back(amrex::length(erf.boxArray()[0]).y);
  n_cells.push_back(amrex::length(erf.boxArray()[0]).z);
  num_pts = (amrex::length(erf.boxArray()[0]).x)*(amrex::length(erf.boxArray()[0]).y)*(amrex::length(erf.boxArray()[0]).z);
#endif

  amrex::Vector<std::string> plot_var_names;
  amrex::Vector<std::pair<int, int>> plot_var_map;
  for (int typ = 0; typ < erf.desc_lst.size(); typ++)
    for (int comp = 0; comp < erf.desc_lst[typ].nComp(); comp++) {
      if ( erf.parent->isStatePlotVar(erf.desc_lst[typ].name(comp)) &&
           erf.desc_lst[typ].getType() == amrex::IndexType::TheCellType()) {
        plot_var_map.push_back(std::pair<int, int>(typ, comp));
        plot_var_names.push_back(erf.desc_lst[typ].name(comp));
      }
  }

  int num_derive = 0;
  std::list<std::string> derive_names;
  const std::list<amrex::DeriveRec>& dlist = erf.derive_lst.dlist();

  for (std::list<amrex::DeriveRec>::const_iterator it = dlist.begin(), end = dlist.end(); it != end; ++it) {
    if (erf.parent->isDerivePlotVar(it->name())) {
       derive_names.push_back(it->name());
       plot_var_names.push_back(it->name());
       num_derive += it->numDerive();
    }
  }

  int n_data_items = plot_var_map.size() + num_derive;

  const std::string nt_name   = "num_time_steps";
  const std::string ndim_name = "num_geo_dimensions";
  const std::string np_name   = "num_points_per_block";
  const std::string nb_name   = "num_blocks";
  const std::string nx_name   = "NX";
  const std::string ny_name   = "NY";
  const std::string nz_name   = "NZ";
  const std::string var_name  = "VAR_NAMES";
  const std::string flev_name = "FINEST_LEVEL";

  ncf.enter_def_mode();
  ncf.put_attr("title", "ERF NetCDF Plot data output");
  ncf.def_dim(nt_name,   NC_UNLIMITED);
  ncf.def_dim(ndim_name, AMREX_SPACEDIM);
  ncf.def_dim(np_name,   num_pts);
  ncf.def_dim(nb_name,   nblocks);
  ncf.def_dim(var_name,  n_data_items);
  ncf.def_dim(flev_name, flev);

  ncf.def_dim(nx_name,   n_cells[0]);
  ncf.def_dim(ny_name,   n_cells[1]);
  ncf.def_dim(nz_name,   n_cells[2]);

  ncf.def_var("VARNAMES",   NC_STRING, {var_name});
  ncf.def_var("probLo"  ,   NC_FLOAT,  {ndim_name});
  ncf.def_var("probHi"  ,   NC_FLOAT,  {ndim_name});
  ncf.def_var("refRatio",   NC_INT,    {flev_name});
  ncf.def_var("levelSteps", NC_INT,    {flev_name});

  ncf.def_var("Geom.smallend", NC_INT, {flev_name, ndim_name});
  ncf.def_var("Geom.bigend"  , NC_INT, {flev_name, ndim_name});
  ncf.def_var("CellSize"     , NC_FLOAT, {flev_name, ndim_name});

  ncf.def_var("x_grid", NC_FLOAT, {nb_name, nx_name});
  ncf.def_var("y_grid", NC_FLOAT, {nb_name, ny_name});
  ncf.def_var("z_grid", NC_FLOAT, {nb_name, nz_name});

  for (i = 0; i < plot_var_names.size(); i++) {
    ncf.def_var(plot_var_names[i], NC_FLOAT, {nb_name, np_name});
  }
  ncf.exit_def_mode();

  amrex::Real cur_time = erf.state[State_Type].curTime();
  input_version = 1;

  if (erf.level == 0 && amrex::ParallelDescriptor::IOProcessor()) {
    //
    // write out the netcdf plotfile head information.
    //
    if (n_data_items == 0)
      amrex::Error("Must specify at least one valid data item to plot");

    ncf.put_attr("PlotFileType", erf.thePlotFileType());
    ncf.put_attr("number_variables", std::vector<int>{n_data_items});
    ncf.put_attr("input_version", std::vector<int>{input_version});

    amrex::Vector<const char*> variable_names;
    for (i = 0; i < plot_var_map.size(); i++) {
      int typ = plot_var_map[i].first;
      int comp = plot_var_map[i].second;
      variable_names.push_back(erf.desc_lst[typ].name(comp).c_str());
    }

    for(const auto& d_var_name : derive_names) {
      variable_names.push_back(d_var_name.c_str());
    }
    ncf.var("VARNAMES").put(variable_names.data(), {0}, {n_data_items});

    ncf.put_attr("space_dimension", std::vector<int>{AMREX_SPACEDIM});
    ncf.put_attr("current_time", std::vector<double>{erf.parent->cumTime()});

    ncf.put_attr("FinestLevel", std::vector<int>{erf.parent->finestLevel()});
    ncf.put_attr("CurrentLevel", std::vector<int>{erf.level});

    amrex::Vector<amrex::Real> probLo;
    amrex::Vector<amrex::Real> probHi;
    for (i = 0; i < AMREX_SPACEDIM; i++) {
      probLo.push_back(erf.Geom().ProbLo(i));
      probHi.push_back(erf.Geom().ProbHi(i));
    }
    ncf.var("probLo").put(probLo.data(), {0}, {AMREX_SPACEDIM});
    ncf.var("probHi").put(probHi.data(), {0}, {AMREX_SPACEDIM});

    amrex::Vector<int> refRatio;
    for (i = 0; i < flev; i++)
      refRatio.push_back(erf.parent->refRatio(i)[0]);
    ncf.var("refRatio").put(refRatio.data(), {0}, {flev});

    amrex::Vector<int> levelSteps;
    for (i = 0; i <= flev; i++)
      levelSteps.push_back(erf.parent->levelSteps(i));
    ncf.var("levelSteps").put(levelSteps.data(), {0}, {flev});

    amrex::Vector<int> smallend;
    amrex::Vector<int> bigend;
    for (i = 0; i <= flev; i++) {
      smallend.clear(); bigend.clear();
      for (j = 0; j < AMREX_SPACEDIM; j++) {
         smallend.push_back(erf.parent->Geom(i).Domain().smallEnd(j));
         bigend.push_back(erf.parent->Geom(i).Domain().bigEnd(j));
      }
      ncf.var("Geom.smallend").put(smallend.data(), {i, 0}, {1, AMREX_SPACEDIM});
      ncf.var("Geom.bigend").put(bigend.data(), {i, 0}, {1, AMREX_SPACEDIM});
    }

    amrex::Vector<amrex::Real> CellSize;
    for (i = 0; i <= flev; i++) {
      CellSize.clear();
      for (j = 0; j < AMREX_SPACEDIM; j++) {
        CellSize.push_back(erf.parent->Geom(i).CellSize()[j]);
      }
      ncf.var("CellSize").put(CellSize.data(), {i, 0}, {1, AMREX_SPACEDIM});
    }

    ncf.put_attr("DefaultGeometry", std::vector<int>{amrex::DefaultGeometry().Coord()});

  } // level == 0

  //
  // Force other processors to wait till directory is built.
  //
  amrex::ParallelDescriptor::Barrier();

  if (amrex::ParallelDescriptor::IOProcessor()) {

    std::vector<amrex::Real> x_grid;
    std::vector<amrex::Real> y_grid;
    std::vector<amrex::Real> z_grid;
    for (i = 0; i < erf.grids.size(); ++i) {
      amrex::RealBox gridloc = amrex::RealBox(erf.grids[i], erf.geom.CellSize(), erf.geom.ProbLo());

      x_grid.clear(); y_grid.clear(); z_grid.clear();
      for (auto k1 = 0; k1 < erf.grids[i].length(0); ++k1) {
        x_grid.push_back(gridloc.lo(0)+erf.geom.CellSize(0)*static_cast<amrex::Real>(k1));
      }
      for (auto k2 = 0; k2 < erf.grids[i].length(1); ++k2) {
        y_grid.push_back(gridloc.lo(1)+erf.geom.CellSize(1)*static_cast<amrex::Real>(k2));
      }
      for (auto k3 = 0; k3 < erf.grids[i].length(2); ++k3) {
        z_grid.push_back(gridloc.lo(2)+erf.geom.CellSize(2)*static_cast<amrex::Real>(k3));
      }

      ncf.var("x_grid").put(x_grid.data(), {i, 0}, {1, erf.grids[i].length(0)});
      ncf.var("y_grid").put(y_grid.data(), {i, 0}, {1, erf.grids[i].length(1)});
      ncf.var("z_grid").put(z_grid.data(), {i, 0}, {1, erf.grids[i].length(2)});
    }
  }

  //
  // combine all of the multifabs -- state, derived, etc -- into one multifab -- plotMF.
  // NOTE: we are assuming that each state variable has one component,
  // but a derived variable is allowed to have multiple components.

  int cnt = 0;
  int ncomp = 1;
  const int nGrow = 0;
  amrex::MultiFab plotMF(erf.grids, erf.dmap, n_data_items, nGrow, amrex::MFInfo(), erf.Factory());
  amrex::MultiFab* this_dat = 0;
  //
  // Cull data from state variables -- use no ghost cells.
  //
  for (i = 0; i < plot_var_map.size(); i++) {
    int typ = plot_var_map[i].first;
    int comp = plot_var_map[i].second;
    this_dat = &(erf.state[typ].newData());
    amrex::MultiFab::Copy(plotMF, *this_dat, comp, cnt, 1, nGrow);
    cnt++;
  }
  //
  // Cull data from derived variables.
  //
  if (derive_names.size() > 0) {
    for (std::list<std::string>::const_iterator it = derive_names.begin(),
         end = derive_names.end(); it != end; ++it) {
      const amrex::DeriveRec* rec = erf.derive_lst.get(*it);
      ncomp = rec->numDerive();
      auto derive_dat = erf.derive(*it, cur_time, nGrow);
      amrex::MultiFab::Copy(plotMF, *derive_dat, 0, cnt, ncomp, nGrow);
      cnt += ncomp;
    }
  }

  size_t nfai = 0;
  for (amrex::MFIter fai(plotMF); fai.isValid(); ++fai) {
    auto ncomp = plotMF.nComp();
    auto numpts = plotMF.get(fai).numPts();
    auto box = plotMF.get(fai).box();
    for (int k(0); k < ncomp; ++k) {
       auto data = plotMF.get(fai).dataPtr(k);
       ncf.var(plot_var_names[k]).put(data, {nfai, 0}, {1, numpts});
    }
    nfai++;
  }
  ncf.close();
}

//
// write checkpoint file in NetCDF format for restart use
//
void
IOManager::NCWriteCheckpointFile (const std::string& dir, std::ostream& os, const bool& dump_old)
{
    //
    // Build directory to hold the MultiFabs in the StateData at this level.
    // The directory is relative the the directory containing the Header file.
    //
    std::string LevelDir, FullPath;
    erf.LevelDirectoryNames(dir, LevelDir, FullPath);
    if( ! erf.levelDirectoryCreated) {
      erf.CreateLevelDirectory(dir);
      // ---- Force other processors to wait until directory is built.
      amrex::ParallelDescriptor::Barrier("AmrLevel::checkPoint::dir");
    }

    if (amrex::ParallelDescriptor::IOProcessor())
    {
      os << erf.level << '\n';

      // get the output variable names
      amrex::Vector<std::string> var_names;
      std::map<std::pair<int, int>, int> var_map;
      int inc = 0;
      for (int typ = 0; typ < erf.desc_lst.size(); typ++) {
        for (int comp = 0; comp < erf.desc_lst[typ].nComp(); comp++) {
          std::string name;
          std::pair<int, int> p {std::pair<int, int>(typ, comp)};
          var_map[p] = inc;
          if (erf.desc_lst[typ].name(comp) != "") {
             name = erf.desc_lst[typ].name(comp);
          } else {
            name = EnumToString(static_cast<StateType>(typ));
          }
          var_names.push_back(name.c_str());
          ++inc;
        }
      }

      //
      // use separate name scope for new and old data output, in case
      // the new and old data have different mesh (sometimes, the mesh
      // can be refined in new data).
      //
      {
        // get the multifab data
        amrex::Vector<amrex::MultiFab*> newMF;
        for (int typ = 0; typ < erf.desc_lst.size(); typ++) {
          newMF.push_back(&(erf.get_new_data(typ)));
        }

        // get the number points and size of different variable type, and geometric blocks
        amrex::Vector<int> npts;
        amrex::Vector<int> nsize;
        amrex::Vector<int> nblocks;
        amrex::Vector<std::string> lo_names;
        amrex::Vector<std::string> hi_names;
        amrex::Vector<std::string> typ_names;
        for (int i = 0; i < newMF.size(); ++i) {
           auto new_dataMF = newMF[i];
           auto ncomp      = new_dataMF->nComp();
           auto num_pts    = new_dataMF->get(0).numPts();
           auto box        = new_dataMF->get(0).box();
           int  nbox       = new_dataMF->size();

           std::string typ_name = EnumToString(static_cast<StateType>(i));
           lo_names.push_back("lo_"+typ_name);
           hi_names.push_back("hi_"+typ_name);
           typ_names.push_back("typ_"+typ_name);
           nblocks.push_back(nbox);
           for (int k(0); k < ncomp; ++k) {
              std::pair<int, int> p {std::pair<int, int>(i, k)};
              int index = var_map[p];
              std::string name = var_names[index];
              npts.push_back(num_pts);
              nsize.push_back(nbox);
           }
        }

        int ndesc  = erf.desc_lst.size();
        int ngrids = erf.numGrids();
        int nflev  = erf.parent->finestLevel();

        const std::string ndim_name = "num_geo_dimensions";
        const std::string nl_name   = "finest_levels";
        const std::string ng_name   = "num_grids";

        amrex::Vector<std::string> np_names;
        for (int k = 0; k < npts.size(); ++k) {
          np_names.push_back("num_points_"+std::to_string(k));
        }

        amrex::Vector<std::string> ns_names;
        for (int k = 0; k < nsize.size(); ++k) {
          ns_names.push_back("nsize_"+std::to_string(k));
        }

        amrex::Vector<std::string> nb_names;
        for (int k = 0; k < nblocks.size(); ++k) {
          nb_names.push_back("num_boxs_"+std::to_string(k));
        }

        static const std::string NewSuffix("/SD_New_MF.nc");
        auto ncf_new = ncutils::NCFile::create(FullPath+NewSuffix, NC_CLOBBER | NC_NETCDF4);

        ncf_new.enter_def_mode();
        ncf_new.put_attr("title", "ERF NetCDF CheckPoint Data Output");
        ncf_new.def_dim(ndim_name, AMREX_SPACEDIM);
        ncf_new.def_dim(nl_name,   nflev);
        ncf_new.def_dim(ng_name,   ngrids);

        for (int k = 0; k < var_names.size(); ++k) {
          ncf_new.def_dim(np_names[k], npts[k]);
          ncf_new.def_dim(ns_names[k], nsize[k]);
          ncf_new.def_var(var_names[k], NC_FLOAT, {ns_names[k], np_names[k]});
        }

        for (int k = 0; k < nb_names.size(); ++k) {
          ncf_new.def_dim(nb_names[k] , nblocks[k]);
          ncf_new.def_var(lo_names[k] , NC_INT, {nb_names[k], ndim_name});
          ncf_new.def_var(hi_names[k] , NC_INT, {nb_names[k], ndim_name});
          ncf_new.def_var(typ_names[k], NC_INT, {nb_names[k], ndim_name});
        }

        ncf_new.def_var("Grids.SmallEnd", NC_INT, {ng_name, ndim_name});
        ncf_new.def_var("Grids.BigEnd"  , NC_INT, {ng_name, ndim_name});
        ncf_new.def_var("Grids.BType"   , NC_INT, {ng_name, ndim_name});

        ncf_new.def_var("Domain.SmallEnd", NC_INT,   {ndim_name});
        ncf_new.def_var("Domain.BigEnd"  , NC_INT,   {ndim_name});
        ncf_new.def_var("Domain.BType"   , NC_INT,   {ndim_name});
        ncf_new.def_var("Coord.Offset"   , NC_FLOAT, {ndim_name});
        ncf_new.def_var("Coord.CellSize" , NC_FLOAT, {ndim_name});
        ncf_new.def_var("PDomain.Lo"     , NC_FLOAT, {ndim_name});
        ncf_new.def_var("PDomain.Hi"     , NC_FLOAT, {ndim_name});
        ncf_new.def_var("Geom.Periodic"  , NC_INT,   {ndim_name});
        ncf_new.def_var("RefRatio"       , NC_INT,   {nl_name, ndim_name});
        ncf_new.def_var("DtLevel"        , NC_FLOAT, {nl_name});
        ncf_new.def_var("DtMin"          , NC_FLOAT, {nl_name});
        ncf_new.def_var("NCycle"         , NC_INT,   {nl_name});
        ncf_new.def_var("LevelSteps"     , NC_INT,   {nl_name});
        ncf_new.def_var("LevelCount"     , NC_INT,   {nl_name});
        ncf_new.exit_def_mode();

        //
        // Output geometric data.
        //

        amrex::Real prev_time = erf.state[State_Type].prevTime();
        amrex::Real dt_new = erf.parent->dtLevel(erf.level);
        amrex::Real dt_old = erf.parent->cumTime()-prev_time;

        // scalar to NetCDF as attr
        ncf_new.put_attr("Level", std::vector<int>{erf.level});
        ncf_new.put_attr("nVarType",  std::vector<int>{ndesc});
        ncf_new.put_attr("CheckPointVersion",CheckPointVersion);
        ncf_new.put_attr("AMREX_SPECEDIM",std::vector<int>{AMREX_SPACEDIM});
        ncf_new.put_attr("cumtime",std::vector<float>{erf.parent->cumTime()});
        ncf_new.put_attr("DtNew",std::vector<float>{dt_new});
        ncf_new.put_attr("DtOld",std::vector<float>{dt_old});
        ncf_new.put_attr("max_level",std::vector<int>{erf.parent->maxLevel()});
        ncf_new.put_attr("finest_level",std::vector<int>{erf.parent->finestLevel()});
        ncf_new.put_attr("CoordSys_ID",std::vector<int>{erf.geom.CoordInt()});

        auto domain = erf.Domain();
        amrex::IntVect dsmallend = domain.smallEnd();
        amrex::IntVect dbigend   = domain.bigEnd();
        amrex::IntVect ditype    = domain.type();

        ncf_new.var("Domain.SmallEnd").put(dsmallend.begin(), {0}, {AMREX_SPACEDIM});
        ncf_new.var("Domain.BigEnd").put(dbigend.begin(), {0}, {AMREX_SPACEDIM});
        ncf_new.var("Domain.BType").put(ditype.begin(), {0}, {AMREX_SPACEDIM});

        auto offset   = erf.geom.Offset();
        auto cellsize = erf.geom.CellSize();
        ncf_new.var("Coord.Offset").put(offset, {0}, {AMREX_SPACEDIM});
        ncf_new.var("Coord.CellSize").put(cellsize, {0}, {AMREX_SPACEDIM});

        ncf_new.var("PDomain.Lo").put(erf.geom.ProbDomain().lo(), {0}, {AMREX_SPACEDIM});
        ncf_new.var("PDomain.Hi").put(erf.geom.ProbDomain().hi(), {0}, {AMREX_SPACEDIM});

        amrex::IntVect periodic = static_cast<amrex::IntVect>(erf.geom.isPeriodic());
        ncf_new.var("Geom.Periodic").put(periodic.begin(), {0}, {AMREX_SPACEDIM});

        for(auto ilev=0; ilev<nflev; ++ilev)
           ncf_new.var("RefRatio").put(erf.parent->refRatio(erf.level).begin(), {ilev, 0}, {1, AMREX_SPACEDIM});

        std::vector<amrex::Real> dtlevel;
        for(auto ilev=0; ilev<nflev; ++ilev)
          dtlevel.push_back(erf.parent->dtLevel(ilev));
        ncf_new.var("DtLevel").put(dtlevel.data(), {0}, {nflev});

        std::vector<amrex::Real> dtmin;
        for(auto ilev=0; ilev<nflev; ++ilev)
           dtmin.push_back(erf.parent->dtMin(ilev));
        ncf_new.var("DtMin").put(dtmin.data(), {0}, {nflev});

        std::vector<int> ncycle;
        for(auto ilev=0; ilev<nflev; ++ilev)
           ncycle.push_back(erf.parent->nCycle(ilev));
        ncf_new.var("NCycle").put(ncycle.data(), {0}, {nflev});

        std::vector<int> levelsteps;
        for(auto ilev=0; ilev<nflev; ++ilev)
           levelsteps.push_back(erf.parent->levelSteps(ilev));
        ncf_new.var("LevelSteps").put(levelsteps.data(), {0}, {nflev});

        std::vector<int> levelcount;
        for(auto ilev=0; ilev<nflev; ++ilev)
           levelcount.push_back(erf.parent->levelCount(ilev));
        ncf_new.var("LevelCount").put(levelcount.data(), {0}, {nflev});

        for (auto ig=0; ig<ngrids; ++ig) {
           amrex::Box b = erf.grids[ig];
           amrex::IntVect blo    = b.smallEnd();
           amrex::IntVect bhi    = b.bigEnd();
           amrex::IntVect btype  = b.type();

           ncf_new.var("Grids.SmallEnd").put(blo.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
           ncf_new.var("Grids.BigEnd").put(bhi.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
           ncf_new.var("Grids.BType").put(btype.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
        }

        //
        // output state data
        // NOTE: only solver variables are outputed, the derived variables are not output in the
        //       checkpoint file, however, they are output in the plotfile.
        //
        for (int i = 0; i < ndesc; i++) {
            auto new_dataMF = newMF[i];
            for (amrex::MFIter new_mfi(*new_dataMF); new_mfi.isValid(); ++new_mfi) {
                auto ncomp   = new_dataMF->nComp();
                auto box     = new_dataMF->get(new_mfi).box();
                auto num_pts = new_dataMF->get(new_mfi).numPts();

                amrex::IntVect smallend = box.smallEnd();
                amrex::IntVect bigend   = box.bigEnd();
                amrex::IntVect itype    = box.type();

                ncf_new.var(lo_names[i] ).put(smallend.begin(), {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});
                ncf_new.var(hi_names[i] ).put(bigend.begin()  , {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});
                ncf_new.var(typ_names[i]).put(itype.begin()   , {new_mfi.index(), 0}, {1, AMREX_SPACEDIM});

                for (int k(0); k < ncomp; ++k) {
                   std::pair<int, int> p {std::pair<int, int>(i, k)};
                   int index = var_map[p];
                   auto dataPtr = new_dataMF->get(new_mfi).dataPtr(k);
                   ncf_new.var(var_names[index]).put(dataPtr, {new_mfi.index(), 0}, {1, num_pts});
                }
            }
        }
        ncf_new.close();
      }
      //
      // write data at previous timestep to NetCDF file
      //
      if (dump_old) {
         amrex::Vector<amrex::MultiFab*> oldMF;
         for (int typ = 0; typ < erf.desc_lst.size(); typ++) {
            oldMF.push_back(&erf.get_old_data(typ));
         }

        // get the number points and size of different variable type, and geometric blocks
        amrex::Vector<int> npts;
        amrex::Vector<int> nsize;
        amrex::Vector<int> nblocks;
        amrex::Vector<std::string> lo_names;
        amrex::Vector<std::string> hi_names;
        amrex::Vector<std::string> typ_names;
        for (int i = 0; i < oldMF.size(); ++i) {
           auto old_dataMF = oldMF[i];
           auto ncomp      = old_dataMF->nComp();
           auto num_pts    = old_dataMF->get(0).numPts();
           auto box        = old_dataMF->get(0).box();
           int  nbox       = old_dataMF->size();

           std::string typ_name = EnumToString(static_cast<StateType>(i));
           lo_names.push_back("lo_"+typ_name);
           hi_names.push_back("hi_"+typ_name);
           typ_names.push_back("typ_"+typ_name);
           nblocks.push_back(nbox);
           for (int k(0); k < ncomp; ++k) {
              std::pair<int, int> p {std::pair<int, int>(i, k)};
              int index = var_map[p];
              std::string name = var_names[index];
              npts.push_back(num_pts);
              nsize.push_back(nbox);
           }
        }

        int ndesc  = erf.desc_lst.size();
        int ngrids = erf.numGrids();
        int nflev  = erf.parent->finestLevel();

        const std::string ndim_name = "num_geo_dimensions";
        const std::string nl_name   = "finest_levels";
        const std::string ng_name   = "num_grids";

        amrex::Vector<std::string> np_names;
        for (int k = 0; k < npts.size(); ++k) {
          np_names.push_back("num_points_"+std::to_string(k));
        }

        amrex::Vector<std::string> ns_names;
        for (int k = 0; k < nsize.size(); ++k) {
          ns_names.push_back("nsize_"+std::to_string(k));
        }

        amrex::Vector<std::string> nb_names;
        for (int k = 0; k < nblocks.size(); ++k) {
          nb_names.push_back("num_boxs_"+std::to_string(k));
        }


        static const std::string OldSuffix("/SD_Old_MF.nc");
        auto ncf_old = ncutils::NCFile::create(FullPath+OldSuffix, NC_CLOBBER | NC_NETCDF4);

        ncf_old.enter_def_mode();
        ncf_old.put_attr("title", "ERF NetCDF CheckPoint Data Output");
        ncf_old.def_dim(ndim_name, AMREX_SPACEDIM);
        ncf_old.def_dim(nl_name,   nflev);
        ncf_old.def_dim(ng_name,   ngrids);

        for (int k = 0; k < var_names.size(); ++k) {
          ncf_old.def_dim(np_names[k], npts[k]);
          ncf_old.def_dim(ns_names[k], nsize[k]);
          ncf_old.def_var(var_names[k], NC_FLOAT, {ns_names[k], np_names[k]});
        }

        for (int k = 0; k < nb_names.size(); ++k) {
          ncf_old.def_dim(nb_names[k] , nblocks[k]);
          ncf_old.def_var(lo_names[k] , NC_INT, {nb_names[k], ndim_name});
          ncf_old.def_var(hi_names[k] , NC_INT, {nb_names[k], ndim_name});
          ncf_old.def_var(typ_names[k], NC_INT, {nb_names[k], ndim_name});
        }

        ncf_old.def_var("Grids.SmallEnd", NC_INT, {ng_name, ndim_name});
        ncf_old.def_var("Grids.BigEnd"  , NC_INT, {ng_name, ndim_name});
        ncf_old.def_var("Grids.BType"   , NC_INT, {ng_name, ndim_name});

        ncf_old.def_var("Domain.SmallEnd", NC_INT,   {ndim_name});
        ncf_old.def_var("Domain.BigEnd"  , NC_INT,   {ndim_name});
        ncf_old.def_var("Domain.BType"   , NC_INT,   {ndim_name});
        ncf_old.def_var("Coord.Offset"   , NC_FLOAT, {ndim_name});
        ncf_old.def_var("Coord.CellSize" , NC_FLOAT, {ndim_name});
        ncf_old.def_var("PDomain.Lo"     , NC_FLOAT, {ndim_name});
        ncf_old.def_var("PDomain.Hi"     , NC_FLOAT, {ndim_name});
        ncf_old.def_var("Geom.Periodic"  , NC_INT,   {ndim_name});
        ncf_old.def_var("RefRatio"       , NC_INT,   {nl_name, ndim_name});
        ncf_old.def_var("DtLevel"        , NC_FLOAT, {nl_name});
        ncf_old.def_var("DtMin"          , NC_FLOAT, {nl_name});
        ncf_old.def_var("NCycle"         , NC_INT,   {nl_name});
        ncf_old.def_var("LevelSteps"     , NC_INT,   {nl_name});
        ncf_old.def_var("LevelCount"     , NC_INT,   {nl_name});
        ncf_old.exit_def_mode();

        //
        // Output geometric data.
        //

        amrex::Real prev_time = erf.state[State_Type].prevTime();
        amrex::Real dt_new = erf.parent->dtLevel(erf.level);
        amrex::Real dt_old = erf.parent->cumTime()-prev_time;

        // scalar to NetCDF as attr
        ncf_old.put_attr("Level", std::vector<int>{erf.level});
        ncf_old.put_attr("nVarType",  std::vector<int>{ndesc});
        ncf_old.put_attr("CheckPointVersion",CheckPointVersion);
        ncf_old.put_attr("AMREX_SPECEDIM",std::vector<int>{AMREX_SPACEDIM});
        ncf_old.put_attr("cumtime",std::vector<float>{erf.parent->cumTime()});
        ncf_old.put_attr("DtNew",std::vector<float>{dt_new});
        ncf_old.put_attr("DtOld",std::vector<float>{dt_old});
        ncf_old.put_attr("max_level",std::vector<int>{erf.parent->maxLevel()});
        ncf_old.put_attr("finest_level",std::vector<int>{erf.parent->finestLevel()});
        ncf_old.put_attr("CoordSys_ID",std::vector<int>{erf.geom.CoordInt()});

        auto domain = erf.Domain();
        amrex::IntVect dsmallend = domain.smallEnd();
        amrex::IntVect dbigend   = domain.bigEnd();
        amrex::IntVect ditype    = domain.type();

        ncf_old.var("Domain.SmallEnd").put(dsmallend.begin(), {0}, {AMREX_SPACEDIM});
        ncf_old.var("Domain.BigEnd").put(dbigend.begin(), {0}, {AMREX_SPACEDIM});
        ncf_old.var("Domain.BType").put(ditype.begin(), {0}, {AMREX_SPACEDIM});

        auto offset   = erf.geom.Offset();
        auto cellsize = erf.geom.CellSize();
        ncf_old.var("Coord.Offset").put(offset, {0}, {AMREX_SPACEDIM});
        ncf_old.var("Coord.CellSize").put(cellsize, {0}, {AMREX_SPACEDIM});

        ncf_old.var("PDomain.Lo").put(erf.geom.ProbDomain().lo(), {0}, {AMREX_SPACEDIM});
        ncf_old.var("PDomain.Hi").put(erf.geom.ProbDomain().hi(), {0}, {AMREX_SPACEDIM});

        amrex::IntVect periodic = static_cast<amrex::IntVect>(erf.geom.isPeriodic());
        ncf_old.var("Geom.Periodic").put(periodic.begin(), {0}, {AMREX_SPACEDIM});

        for(auto ilev=0; ilev<nflev; ++ilev)
           ncf_old.var("RefRatio").put(erf.parent->refRatio(erf.level).begin(), {ilev, 0}, {1, AMREX_SPACEDIM});

        std::vector<amrex::Real> dtlevel;
        for(auto ilev=0; ilev<nflev; ++ilev)
          dtlevel.push_back(erf.parent->dtLevel(ilev));
        ncf_old.var("DtLevel").put(dtlevel.data(), {0}, {nflev});

        std::vector<amrex::Real> dtmin;
        for(auto ilev=0; ilev<nflev; ++ilev)
           dtmin.push_back(erf.parent->dtMin(ilev));
        ncf_old.var("DtMin").put(dtmin.data(), {0}, {nflev});

        std::vector<int> ncycle;
        for(auto ilev=0; ilev<nflev; ++ilev)
           ncycle.push_back(erf.parent->nCycle(ilev));
        ncf_old.var("NCycle").put(ncycle.data(), {0}, {nflev});

        std::vector<int> levelsteps;
        for(auto ilev=0; ilev<nflev; ++ilev)
           levelsteps.push_back(erf.parent->levelSteps(ilev));
        ncf_old.var("LevelSteps").put(levelsteps.data(), {0}, {nflev});

        std::vector<int> levelcount;
        for(auto ilev=0; ilev<nflev; ++ilev)
           levelcount.push_back(erf.parent->levelCount(ilev));
        ncf_old.var("LevelCount").put(levelcount.data(), {0}, {nflev});

        for (auto ig=0; ig<ngrids; ++ig) {
           amrex::Box b = erf.grids[ig];
           amrex::IntVect blo    = b.smallEnd();
           amrex::IntVect bhi    = b.bigEnd();
           amrex::IntVect btype  = b.type();

           ncf_old.var("Grids.SmallEnd").put(blo.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
           ncf_old.var("Grids.BigEnd").put(bhi.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
           ncf_old.var("Grids.BType").put(btype.begin(), {ig, 0}, {1, AMREX_SPACEDIM});
        }

        //
        // output state data
        // NOTE: only solver variables are outputed, the derived variables are not output in the
        //       checkpoint file, however, they are output in the plotfile.
        //
        for (int i = 0; i < ndesc; i++) {
            auto old_dataMF = oldMF[i];
            for (amrex::MFIter old_mfi(*old_dataMF); old_mfi.isValid(); ++old_mfi) {
                auto ncomp   = old_dataMF->nComp();
                auto box     = old_dataMF->get(old_mfi).box();
                auto num_pts = old_dataMF->get(old_mfi).numPts();

                amrex::IntVect smallend = box.smallEnd();
                amrex::IntVect bigend   = box.bigEnd();
                amrex::IntVect itype    = box.type();

                ncf_old.var(lo_names[i] ).put(smallend.begin(), {old_mfi.index(), 0}, {1, AMREX_SPACEDIM});
                ncf_old.var(hi_names[i] ).put(bigend.begin()  , {old_mfi.index(), 0}, {1, AMREX_SPACEDIM});
                ncf_old.var(typ_names[i]).put(itype.begin()   , {old_mfi.index(), 0}, {1, AMREX_SPACEDIM});

                for (int k(0); k < ncomp; ++k) {
                   std::pair<int, int> p {std::pair<int, int>(i, k)};
                   int index = var_map[p];
                   auto dataPtr = old_dataMF->get(old_mfi).dataPtr(k);
                   ncf_old.var(var_names[index]).put(dataPtr, {old_mfi.index(), 0}, {1, num_pts});
                }
            }
        }
        ncf_old.close();
      }

      erf.levelDirectoryCreated = false;  // ---- now that the checkpoint is finished
    }
    else {
       std::cout << "No NetCDF checkPoint Data outputed!" << '\n';
    }
 }


